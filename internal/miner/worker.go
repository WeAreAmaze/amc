// Copyright 2022 The AmazeChain Authors
// This file is part of the AmazeChain library.
//
// The AmazeChain library is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The AmazeChain library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the AmazeChain library. If not, see <http://www.gnu.org/licenses/>.

package miner

import (
	"context"
	types2 "github.com/amazechain/amc/internal/avm/types"
	"sync"
	"sync/atomic"
	"time"

	"github.com/amazechain/amc/common"
	block2 "github.com/amazechain/amc/common/block"
	"github.com/amazechain/amc/common/transaction"
	"github.com/amazechain/amc/common/txs_pool"
	"github.com/amazechain/amc/common/types"
	"github.com/amazechain/amc/conf"
	"github.com/amazechain/amc/internal/avm"
	"github.com/amazechain/amc/internal/avm/params"
	"github.com/amazechain/amc/internal/avm/vm"
	"github.com/amazechain/amc/internal/consensus"
	"github.com/amazechain/amc/log"
	event "github.com/amazechain/amc/modules/event/v2"
	"github.com/amazechain/amc/modules/statedb"
	mapset "github.com/deckarep/golang-set"
	"golang.org/x/sync/errgroup"
)

type task struct {
	receipts  []*block2.Receipt
	state     *statedb.StateDB
	block     block2.IBlock
	createdAt time.Time
}

type newWorkReq struct {
	interrupt *int32
	noempty   bool
	timestamp int64
}

type generateParams struct {
	timestamp  uint64        // The timstamp for sealing task
	parentHash types.Hash    // Parent block hash, empty means the latest chain head
	coinbase   types.Address // The fee recipient address for including transaction
	random     types.Hash    // The randomness generated by beacon chain, empty before the merge
	noTxs      bool          // Flag whether an empty block without any transaction is expected
}

type environment struct {
	//signer types.Signer

	state     common.IStateDB // apply state changes here
	ancestors mapset.Set      // ancestor set (used for checking uncle parent validity)
	family    mapset.Set      // family set (used for checking uncle invalidity)
	tcount    int             // tx count in cycle
	gasPool   *common.GasPool // available gas used to pack transactions
	coinbase  types.Address

	header   *block2.Header
	txs      []*transaction.Transaction
	receipts []*block2.Receipt
}

func (env *environment) copy() *environment {
	cpy := &environment{
		ancestors: env.ancestors.Clone(),
		family:    env.family.Clone(),
		tcount:    env.tcount,
		coinbase:  env.coinbase,
		header:    block2.CopyHeader(env.header),
		receipts:  env.receipts,
	}
	if env.gasPool != nil {
		gasPool := *env.gasPool
		cpy.gasPool = &gasPool
	}

	cpy.txs = make([]*transaction.Transaction, len(env.txs))
	copy(cpy.txs, env.txs)
	return cpy
}

const (
	minPeriodInterval         = 1 // 1s
	staleThreshold            = 7
	commitInterruptNone int32 = iota
	commitInterruptNewHead
	commitInterruptResubmit
)

type worker struct {
	engine  consensus.Engine
	chain   common.IBlockChain
	txsPool txs_pool.ITxsPool

	coinbase types.Address
	conf     *conf.ConsensusConfig

	isLocalBlock func(header *block2.Header) bool
	pendingTasks map[types.Hash]*task

	wg sync.WaitGroup
	mu sync.RWMutex

	startCh   chan struct{}
	newWorkCh chan *newWorkReq
	resultCh  chan block2.IBlock
	taskCh    chan *task

	running int32
	newTxs  int32

	group  *errgroup.Group
	ctx    context.Context
	cancel context.CancelFunc
	//current     *environment
	newTaskHook func(*task)
}

func newWorker(ctx context.Context, group *errgroup.Group, conf *conf.ConsensusConfig, engine consensus.Engine, bc common.IBlockChain, txsPool txs_pool.ITxsPool, isLocalBlock func(header *block2.Header) bool, init bool) *worker {
	c, cancel := context.WithCancel(ctx)
	worker := &worker{
		engine:       engine,
		chain:        bc,
		txsPool:      txsPool,
		conf:         conf,
		mu:           sync.RWMutex{},
		startCh:      make(chan struct{}, 1),
		group:        group,
		isLocalBlock: isLocalBlock,
		ctx:          c,
		cancel:       cancel,
		taskCh:       make(chan *task),
		newWorkCh:    make(chan *newWorkReq),
		resultCh:     make(chan block2.IBlock),
		pendingTasks: make(map[types.Hash]*task),
	}
	period := worker.conf.Period
	if period < minPeriodInterval {
		period = minPeriodInterval
	}

	group.Go(func() error {
		return worker.workLoop(time.Duration(int64(period)))
	})

	group.Go(func() error {
		return worker.runLoop()
	})

	group.Go(func() error {
		return worker.taskLoop()
	})

	group.Go(func() error {
		return worker.resultLoop()
	})

	if init {
		worker.startCh <- struct{}{}
	}

	return worker
}

func (w *worker) start() {
	atomic.StoreInt32(&w.running, 1)
	w.startCh <- struct{}{}
}

func (w *worker) stop() {
	atomic.StoreInt32(&w.running, 0)
}

func (w *worker) close() {

}

func (w *worker) isRunning() bool {
	return atomic.LoadInt32(&w.running) == 1
}
func (w *worker) setCoinbase(addr types.Address) {
	w.mu.Lock()
	defer w.mu.Unlock()
	w.coinbase = addr
}

func (w *worker) runLoop() error {
	defer w.cancel()
	defer w.stop()
	for {
		select {
		case <-w.ctx.Done():
			return w.ctx.Err()
		case req := <-w.newWorkCh:
			w.commitWork(req.interrupt, req.noempty, req.timestamp)
		}
	}
}

func (w *worker) resultLoop() error {
	defer w.cancel()
	defer w.stop()

	for {
		select {
		case <-w.ctx.Done():
			return w.ctx.Err()
		case block := <-w.resultCh:
			if block == nil {
				continue
			}
			var (
				sealhash = w.engine.SealHash(block.Header())
				hash     = block.Hash()
			)
			w.mu.RLock()
			task, exist := w.pendingTasks[sealhash]
			w.mu.RUnlock()
			if !exist {
				log.Error("Block found but no relative pending task", "number", block.Number64().Uint64(), "sealhash", sealhash, "hash", hash)
				continue
			}
			log.Info("Successfully sealed new block",
				"sealhash", sealhash,
				"hash", hash,
				"number", block.Number64().Uint64(),
				"used gas", block.GasUsed(),
				"diff", block.Difficulty().Uint64(),
				"elapsed", common.PrettyDuration(time.Since(task.createdAt)))
			w.chain.SealedBlock(block)
		}
	}
}

func (w *worker) taskLoop() error {
	defer w.cancel()
	defer w.stop()

	var (
		stopCh chan struct{}
		prev   types.Hash
	)

	interrupt := func() {
		if stopCh != nil {
			close(stopCh)
			stopCh = nil
		}
	}

	for {
		select {
		case <-w.ctx.Done():
			return w.ctx.Err()
		case task := <-w.taskCh:

			if w.newTaskHook != nil {
				w.newTaskHook(task)
			}

			sealHash := w.engine.SealHash(task.block.Header())
			hash := task.block.Hash()
			if sealHash == prev {
				continue
			}
			interrupt()
			stopCh, prev = make(chan struct{}), sealHash
			w.mu.Lock()
			w.pendingTasks[sealHash] = task
			w.mu.Unlock()

			if err := w.engine.Seal(w.chain, task.block, w.resultCh, stopCh); err != nil {
				w.mu.Lock()
				delete(w.pendingTasks, sealHash)
				w.mu.Unlock()
				log.Warn("delete task", "sealHash", sealHash, "hash", hash, "err", err)
			} else {
				log.Debug("send task", "sealHash", sealHash, "hash", hash)
			}

		}
	}
}

func (w *worker) commitWork(interrupt *int32, noempty bool, timestamp int64) {
	start := time.Now()
	if w.isRunning() {
		if w.coinbase == (types.Address{}) {
			return
		}
	}

	work, err := w.prepareWork(&generateParams{timestamp: uint64(timestamp), coinbase: w.coinbase})
	if err != nil {
		log.Error("cannot prepare work", "err", err)
		return
	}

	if err := w.fillTransactions(interrupt, work); err != nil {
		return
	}

	_ = w.commit(work, nil, true, start)
}

func (w *worker) workLoop(period time.Duration) error {
	defer w.cancel()
	defer w.stop()
	var (
		interrupt *int32
		//minRecommit = period // minimal resubmit interval specified by user.
		timestamp int64 // timestamp for each round of sealing.
	)

	newBlockCh := make(chan common.ChainHighestBlock)
	defer close(newBlockCh)

	newBlockSub := event.GlobalEvent.Subscribe(newBlockCh)
	defer newBlockSub.Unsubscribe()

	commit := func(noempty bool, s int32) {
		if interrupt != nil {
			atomic.StoreInt32(interrupt, s)
		}
		interrupt = new(int32)
		select {
		case w.newWorkCh <- &newWorkReq{interrupt: interrupt, noempty: noempty, timestamp: timestamp}:
		case <-w.ctx.Done():
			return
		}
		//timer.Reset(recommit)
		//atomic.StoreInt32(&w.newTxs, 0)
	}

	clearPending := func(number types.Int256) {
		w.mu.Lock()
		for h, t := range w.pendingTasks {
			if number.Compare(t.block.Number64().Add(types.NewInt64(staleThreshold))) < 1 {
				delete(w.pendingTasks, h)
			}
		}
		w.mu.Unlock()
	}

	for {
		select {
		case <-w.ctx.Done():
			return w.ctx.Err()
		case <-w.startCh:
			clearPending(w.chain.CurrentBlock().Number64())
			timestamp = time.Now().Unix()
			commit(false, commitInterruptNewHead)

		case blockEvent := <-newBlockCh:
			clearPending(blockEvent.Block.Number64())
			timestamp = time.Now().Unix()
			commit(false, commitInterruptNewHead)
		case err := <-newBlockSub.Err():
			return err
		}
	}
}

func (w *worker) fillTransactions(interrupt *int32, env *environment) error {
	// todo fillTx
	env.txs = []*transaction.Transaction{}
	txs, err := w.txsPool.GetTransaction()
	if err != nil {
		log.Warn("get transaction error", "err", err)
		return err
	}

	log.Debugf("txs len:%d", len(txs))
	// todo run commitTransactions
	ethDb := avm.NewDBStates(env.state)
	snap := ethDb.Snapshot()
	for _, tx := range txs {
		hash, _ := tx.Hash()
		ethDb.Prepare(types2.FromAmcHash(hash), env.tcount)
		receipt, err := avm.ApplyTransaction(params.AmazeChainConfig, w.chain, &w.coinbase, env.gasPool, ethDb, env.header, tx, &env.header.GasUsed, vm.Config{})
		if err != nil {
			log.Errorf("commit transaction error, err:%v", err)
			ethDb.RevertToSnapshot(snap)
			continue
		}
		env.tcount++
		env.txs = append(env.txs, tx)
		env.receipts = append(env.receipts, receipt)
	}

	return nil
}

func (w *worker) prepareWork(params *generateParams) (*environment, error) {
	w.mu.RLock()
	defer w.mu.RUnlock()

	timestamp := params.timestamp

	parent := w.chain.CurrentBlock()
	if parent.Time() >= uint64(params.timestamp) {
		timestamp = parent.Time() + 1
	}

	header := &block2.Header{
		ParentHash: parent.Hash(),
		Coinbase:   w.coinbase,
		Number:     parent.Number64().Add(types.NewInt64(1)),
		GasLimit:   CalcGasLimit(parent.GasLimit(), w.conf.GasCeil),
		Time:       uint64(timestamp),
	}

	if err := w.engine.Prepare(w.chain, header); err != nil {
		return nil, err
	}

	return w.makeEnv(parent.(*block2.Block), header, w.coinbase), nil
}

func (w *worker) makeEnv(parent *block2.Block, header *block2.Header, coinbase types.Address) *environment {
	state := w.chain.StateAt(parent.Hash())
	env := &environment{
		ancestors: mapset.NewSet(),
		family:    mapset.NewSet(),
		coinbase:  coinbase,
		header:    header,
		state:     state,
		gasPool:   new(common.GasPool),
		tcount:    0,
	}

	//todo init gas limit
	//env.gasPool = avm.CalcGasLimit(parent.GasLimit(), 30000000)
	//env.gasPool.AddGas(30000000)
	//if env.gasPool == nil {
	env.gasPool = new(common.GasPool).AddGas(header.GasLimit)
	//}

	for _, ancestor := range w.chain.GetBlocksFromHash(parent.ParentHash(), 3) {
		env.family.Add(ancestor.(*block2.Block).Hash())
		env.ancestors.Add(ancestor.Hash())
	}

	return env
}

func (w *worker) commit(env *environment, interval func(), update bool, start time.Time) error {
	if w.isRunning() {
		if interval != nil {
			interval()
		}

		block, err := w.engine.FinalizeAndAssemble(w.chain, env.header, env.state.(*statedb.StateDB), env.txs, nil, env.receipts)
		if err != nil {
			log.Error("cannot commit task", "err", err)
			return err
		}

		select {
		case w.taskCh <- &task{receipts: env.receipts, block: block, createdAt: time.Now()}:
			log.Info("Commit new sealing work",
				"number", block.Header().Number64(),
				"sealhash", w.engine.SealHash(block.Header()),
				"uncles", 0, "txs", env.tcount,
				"gas", block.GasUsed(),
				"elapsed", common.PrettyDuration(time.Since(start)))
		case <-w.ctx.Done():
			return w.ctx.Err()
		}

	}

	return nil
}
